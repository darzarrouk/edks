import os
import struct # for reading and writing binary files.
import numpy as NP
def layered_disloc(xs, ys, zs, strike, dip, rake, slip, A, xr, yr, edks,\
                   prefix, BIN_EDKS = '${EDKS_BIN}' ):
   """
   [ux, uy, uz] = layered_disloc(xs, ys, zs, strike, dip, rake, slip,
                                 A, xr, yr, edks)

   
    --- INPUT ---
    --- SOURCE INFO
    --- 0D NUMPY arrays, length = number of fault patches
    xs       m, east coord to center of fault patch
    ys       m, north coord to center of fault patch
    zs       m,depth coord to center of fault patch (+ down) 
    strike   deg, clockwise from north 
    dip      deg, 90 is vertical 
    rake     deg, 0 left lateral strike slip, 90 up-dip slip 
    slip     m, slip in the rake direction
    A        m2, surface area of fault patch 
    --- RECEIVER INFO
    1D arrays, length = number of receivers
    xr       m, east coordinate of receivers 
    yr       m, north coordinate of receivers 
    --- ELASTIC STRUCTURE INFO
    edks     string, full name of edks file, e.g., halfspace.edks
    --- FILE NAMING 
    prefix   string, prefix for the IO files generated by sum_layered
    BIN_EDKS string, folder (full path) where EDKS binaries are located. 
    --- OUTPUT ---
    --- 2D arrays, (receivers, fault patches)
    ux     m, east displacement
    uy     m, west displacement
    uz     m, up displacement (+ up)


   """
   # some values I need to define for compatibility with "sum_layered""
   # Since sum_layered was originally thought for modelling rectangular patches.
   np = len(xs) # number of sources
   nrec = len(xr) # number of receivers
   L = NP.sqrt(A)
   W = NP.sqrt(A) 
   npw = 1 # scalar, # point sources per patch in the down dip direction
   npy = 1 # scalar, # point sources per patch in the along strike direction
   BIN_FILE_FMT = 'f' # python float = C/C++ float = Fortran 'real*4' 
   NBYTES_FILE_FMT = 4  # a Fortran (real*4) uses 4 bytes.
   # convert sources from center to top edge of fault patch ("sum_layered" needs that)
   # (see notebook on September 1, 2011)
   sind = NP.sin( dip * NP.pi / 180.0 )
   cosd = NP.cos( dip * NP.pi / 180.0 )
   sins = NP.sin( strike * NP.pi / 180.0 )
   coss = NP.cos( strike * NP.pi / 180.0 )
   # displacement in local coordinates (phi, delta)
   dZ = (W/2.0) * sind
   dD = (W/2.0) * cosd
   # rotation to global coordinates 
   xs = xs - dD * coss
   ys = ys + dD * sins
   zs = zs - dZ
   # Define filenames:
   file_rec = prefix + '.rec'
   file_pat = prefix + '.pat'
   file_dux = prefix + '_ux.dis'
   file_duy = prefix + '_uy.dis'
   file_duz = prefix + '_uz.dis'
   cmd = 'rm -f %s %s %s %s %s' %(file_rec, file_pat, file_dux, file_duy, file_duz)
   os.system(cmd) # delete the files if exist
   
   # write receiver location file (observation points)
   temp = [xr, yr]
   file = open(file_rec, 'wb') 
    
   for k in range(0, nrec):
      for i in range(0, len(temp)):
         file.write( struct.pack( BIN_FILE_FMT, temp[i][k] ) )       
   file.close() 
 
   # write point sources information
   temp = [xs, ys, zs, strike, dip, rake, W, L, slip]
   file = open(file_pat, 'wb');
   for k in range(0, np):
      for i in range(0, len(temp)):
         file.write( struct.pack( BIN_FILE_FMT, temp[i][k] ) )
   file.close()
 
   # call sum_layered
   cmd = '%s/sum_layered %s %s %i %i %i %i' %(BIN_EDKS, edks, prefix, nrec, np, npw, npy)
   print cmd
   os.system(cmd)
    
   # read sum_layered output Greens function
   # ux
   file = open(file_dux, 'rb')
   ux = NP.zeros((nrec, np))
   for j in range(0, np):
      for i in range(0, nrec):
         byteVal = file.read(NBYTES_FILE_FMT)
         if byteVal != '':
            ux[i][j] = struct.unpack('f', byteVal)[0]
         else:
            raise ValueError(' Premature EOF in %s, something nasty happened'%(file_dux))
   file.close()

   # uy
   file = open(file_duy, 'rb')
   uy = NP.zeros((nrec, np))
   for j in range(0, np):
      for i in range(0, nrec):
         byteVal = file.read(NBYTES_FILE_FMT)
         if byteVal != '':
            uy[i][j] = struct.unpack('f', byteVal)[0]
         else:
            raise ValueError('Premature EOF in %s, something nasty happened'%(file_duy))
   file.close()

   # uz
   file = open(file_duz, 'rb')
   uz = NP.zeros((nrec, np))
   for j in range(0, np):
      for i in range(0, nrec):
         byteVal = file.read(NBYTES_FILE_FMT)
         if byteVal != '':
            uz[i][j] = struct.unpack('f', byteVal)[0]
         else:
            raise ValueError('Premature EOF in %s, something nasty happened'%(file_duz))
   file.close()

   # remove IO files.
   cmd = 'rm -f %s %s %s %s %s' %(file_rec, file_pat, file_dux, file_duy, file_duz)
   os.system(cmd)  

   # return the GF matrices
   return [ux, uy, uz]


